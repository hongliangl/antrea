// Copyright 2022 Antrea Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package openflow

import (
	binding "antrea.io/antrea/pkg/ovs/openflow"
)

// OVS pipelines are generated by a framework called FlexiblePipeline. There are some abstractions introduced in this
// framework.
//                +--------------+         +--------------+                                 +--------------+
//                |  feature F1  |         |  feature F2  |                                 |  feature F3  |
//                +--------------+         +--------------+                                 +--------------+
//                /       |       \           /        \                                      /         \
//               /        |        \         /          \                                    /           \
//              /         |         \       /            \                                  /             \
// +-------------+ +-------------+ +-------------+ +-------------+ +-------------+ +-------------+ +-------------+
// |   table A   | |   table B   | |   table C   | |   table D   | |   table E   | |   table F   | |   table     |
// |   stage S1  | |           stage S2          | |           stage S1          | |          stage S4           |
// |                   pipeline P                | |                          pipeline Q                         |
// +-------------+ +-------------+ +-------------+ +-------------+ +-------------+ +-------------+ +-------------+
//          \              |              /                \                          |                  /
//           \             |             /                  \ ------ \                |          /-----/
//            \            |            /                             \               |         /
//            +------------------------+                              +-------------------------+
//            |       pipeline P       |                              |        pipeline Q       |
//            |       - table A        |                              |        - table D        |
//            |       - table B        |                              |        - table F        |
//            |       - table C        |                              |        - table G        |
//            +------------------------+                              +-------------------------+

// feature is the interface to program a major function in Antrea data path. The following structures implement this interface:
// - featurePodConnectivity, implementation of connectivity for Pods, activated by default.
// - featureNetworkPolicy, implementation of K8s NetworkPolicy and Antrea NetworkPolicy, activated by default.
// - featureService, implementation of K8s Service, activated by default.
// - featureEgress, implementation of Egress, activation is determined by feature gate Egress.
// - featureMulticast, implementation of multicast, activation is determined by feature gate Multicast,
// - featureTraceflow, implementation of Traceflow.
type feature interface {
	// getFeatureName returns the name of the feature.
	getFeatureName() string
	// getRequiredTables returns a slice of required tables of the feature.
	getRequiredTables() []*Table
	// initFlows returns the initial flows of the feature.
	initFlows() []binding.Flow
	// replayFlows returns the fixed and cached flows that need to be replayed after OVS is reconnected.
	replayFlows() []binding.Flow
}

// Table in FlexiblePipeline is the basic unit to build OVS pipelines. A Table can be referenced by one or more features,
// but its member struct ofTable will be initialized and realized on OVS only when it is referenced by any activated features.
type Table struct {
	name     string
	stage    binding.StageID // All stages are defined in pkg/ovs/openflow/interfaces.go
	pipeline binding.PipelineID
	ofTable  binding.Table
}

// tableOrderCache is used to save the order of all defined tables located in file pkg/agent/openflow/pipeline.go. The tables
// have the same pipeline ID are saved in a slice by order of definition. When building a pipeline, the required table list
// is aggregated from all activated features, and the order of the required tables is decided by the saved order.
var tableOrderCache map[binding.PipelineID][]*Table

// newTable is used to declare a Table. A table should belong to a stage and pipeline defined in file pkg/ovs/openflow/interfaces.go.
// Stage is used to group tables which implement similar functions in a pipeline. Stages include:
//   - ClassifierStage, implementation of classifying packet "category" (tunnel, local gateway or local Pod, etc).
//   - ValidationStage, implementation of validating packets.
//   - ConntrackStateStage, implementation of transforming committed packets in CT zones.
//   - PreRoutingStage, similar to PREROUTING chain of nat table in iptables. DNAT of Service connection is performed in
//     this stage.
//   - EgressSecurityStage, implementation of egress rule for K8s NetworkPolicy and Antrea NetworkPolicy.
//   - RoutingStage, implementation of forwarding packets in L3.
//   - PostRoutingStage, similar to POSTROUTING chain of nat table in iptables. SNAT of Service connection is performed
//     in this stage.
//   - SwitchingStage, implementation of "dmac" table.
//   - IngressSecurityStage, implementation of ingress rule for K8s NetworkPolicy and Antrea NetworkPolicy.
//   - ConntrackStage, implementation of committing non-Service connections.
//   - OutputStage, implementation of outputting packets to correct port.
// Pipeline is used to implement a major function in Antrea data path. At this moment, we have the following pipelines:
//   - Pipeline for IP.
//   - Pipeline for ARP.
//   - Pipeline for multicast.
func newTable(tableName string, stage binding.StageID, pipeline binding.PipelineID) *Table {
	table := &Table{
		name:     tableName,
		stage:    stage,
		pipeline: pipeline,
	}
	if pipeline == binding.PipelineAll {
		tableOrderCache = make(map[binding.PipelineID][]*Table)
	} else {
		tableOrderCache[pipeline] = append(tableOrderCache[pipeline], table)
	}
	return table
}

func (f *Table) GetID() uint8 {
	return f.ofTable.GetID()
}

func (f *Table) GetNext() uint8 {
	return f.ofTable.GetNext()
}

func (f *Table) GetName() string {
	return f.name
}

func (f *Table) GetMissAction() binding.MissActionType {
	return f.ofTable.GetMissAction()
}

func (f *featurePodConnectivity) getRequiredTables() []*Table {
	tables := []*Table{
		// PipelineIP, ClassifierStage
		ClassifierTable,
		// PipelineIP, ValidationStage
		SpoofGuardTable,
		// PipelineIP, ConntrackStateStage
		ConntrackTable,
		ConntrackStateTable,
		// PipelineIP, RoutingStage
		L3ForwardingTable,
		L3DecTTLTable,
		// PipelineIP, SwitchingStage
		L2ForwardingCalcTable,
		// PipelineIP, ConntrackStage
		ConntrackCommitTable,
		// PipelineIP, OutputStage
		L2ForwardingOutTable,
	}

	for _, ipProtocol := range f.ipProtocols {
		switch ipProtocol {
		case binding.ProtocolIPv6:
			tables = append(tables, IPv6Table) // PipelineIP, ValidationStage
		case binding.ProtocolIP:
			tables = append(tables,
				// PipelineARP, ValidationStage
				ARPSpoofGuardTable,
				// PipelineARP, OutputStage
				ARPResponderTable)
			if f.enableMulticast {
				// Pipeline IP, ValidationStage
				tables = append(tables, IPClassifierTable)
			}
		}
	}

	return tables
}

func (f *featureNetworkPolicy) getRequiredTables() []*Table {
	tables := []*Table{
		// PipelineIP, EgressSecurityStage
		EgressRuleTable,
		EgressDefaultTable,
		EgressMetricTable,
		// PipelineIP, IngressSecurityStage
		IngressSecurityClassifierTable,
		IngressRuleTable,
		IngressDefaultTable,
		IngressMetricTable,
	}
	if f.enableAntreaPolicy {
		tables = append(tables,
			// PipelineIP, EgressSecurityStage
			AntreaPolicyEgressRuleTable,
			// PipelineIP, IngressSecurityStage
			AntreaPolicyIngressRuleTable,
		)
	}

	return tables
}

func (f *featureService) getRequiredTables() []*Table {
	if f.enableProxy {
		tables := []*Table{
			// PipelineIP, ConntrackStateStage
			SNATConntrackTable,
			// PipelineIP, PreRoutingStage
			PreRoutingClassifierTable,
			SessionAffinityTable,
			ServiceLBTable,
			EndpointDNATTable,
			// PipelineIP, RoutingStage
			L3ForwardingTable,
			ServiceHairpinMarkTable,
			// PipelineIP, PostRoutingStage
			SNATConntrackCommitTable,
			// PipelineIP, ConntrackStage
			ConntrackCommitTable,
			// PipelineIP, OutputStage
			L2ForwardingOutTable,
		}
		if f.proxyAll {
			// PipelineIP, PreRoutingStage
			tables = append(tables, NodePortMarkTable)
		}
		return tables
	}
	// PipelineIP, PreRoutingStage
	return []*Table{DNATTable}
}

func (f *featureEgress) getRequiredTables() []*Table {
	return []*Table{
		// PipelineIP, RoutingStage
		L3ForwardingTable,
		// PipelineIP, PostRoutingStage
		SNATTable,
	}
}

func (f *featureMulticast) getRequiredTables() []*Table {
	return []*Table{
		// PipelineMulticast, L3ForwardingTable
		MulticastTable,
	}
}

func (f *featureTraceflow) getRequiredTables() []*Table {
	return nil
}

// traceableFeature is the interface to support Traceflow in Antrea data path. Any other feature expected to trace the
// packet status with its flow entries needs to implement this interface. The following structures implement this interface:
// - featurePodConnectivity.
// - featureNetworkPolicy.
// - featureService.
type traceableFeature interface {
	// flowsToTrace returns the flows to be installed when a packet tracing request is created.
	flowsToTrace(dataplaneTag uint8,
		ovsMetersAreSupported,
		liveTraffic,
		droppedOnly,
		receiverOnly bool,
		packet *binding.Packet,
		ofPort uint32,
		timeoutSeconds uint16) []binding.Flow
}
